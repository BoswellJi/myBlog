import{_ as i,c as e,e as a,o as n}from"./app-XEG1kVcG.js";const s={};function t(p,l){return n(),e("div",null,l[0]||(l[0]=[a(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><ul><li>树的节点：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">function node(data,left,right){</span>
<span class="line">  this.data = data;</span>
<span class="line">  this.left = left;</span>
<span class="line">  this.right = right;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="树结构" tabindex="-1"><a class="header-anchor" href="#树结构"><span>树结构</span></a></h2><ul><li><p>定义:</p></li><li><p>优势:</p><ul><li>增，删，查 非常快</li></ul></li><li><p>劣势:</p></li><li><p>树的三个概念</p><ul><li>高度 （从下往上，从0开始）</li><li>深度 （从上往下，从0开始）</li><li>层级 （从上往下，从1开始）</li></ul></li><li><p>分类:</p><ul><li><p>无序树</p></li><li><p>有序树</p></li><li><p>二叉查找树</p><ul><li><code>任意一个节点， 其左子树中的每个节点的值， 都要小于这个节点的值， 而右子树节点的值都大于这个节点的值</code> ，这种二叉树就叫作满二叉查找树。</li></ul></li><li><p>完全二叉树</p><ul><li><code>叶子节点都在最底下两层， 最后一层的叶子节点都靠左排列， 并且除了最后一层， 其他层的节点个数都要达到最大</code> ，这种二叉树叫作完全二叉树。</li></ul></li><li><p>满二叉树</p><ul><li><code>叶子节点全都在最底层， 除了叶子节点之外， 每个节点都有左右两个子节点</code> ，这种二叉树就叫作满二叉树。</li></ul></li></ul></li><li><p>存储方式:</p><ul><li><p>链式存储法（链表）</p></li><li><p>顺序存储法 (数组）</p><ul><li>我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</li><li>优势：节省内存（ <code>这是为什么二叉树要求最后一层子节点都靠左的原因，不会有空子节点</code> ， <code>只浪费了下标为0的存储位置</code> ），通过下标的方式将整棵树串联起来</li><li><em>堆其实就是完全二叉树，一般使用数组存储</em></li></ul></li></ul></li><li><p>树的遍历:</p><ul><li>前序遍历：任意节点，先打印这个节点，再打印左子节点，最后打印右子节点</li><li>中序遍历：任意节点，先打印左子节点，再打印本身节点，最后打印右子节点</li><li>后序遍历：任意节点，先打印左子节点，再打印右子节点，最后打印本身节点</li></ul></li><li><p>节点的分类:</p><ul><li>根节点：没有父节点的节点</li><li>叶子节点：没有子节点的节点</li></ul></li></ul>`,5)]))}const u=i(s,[["render",t],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/books/javascript/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/10%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"树结构","slug":"树结构","link":"#树结构","children":[]}],"git":{"updatedTime":1735558340000,"contributors":[{"name":"jmz","username":"jmz","email":"mingzhuang.ji@ly.com","commits":4,"url":"https://github.com/jmz"},{"name":"Boswell","username":"Boswell","email":"mingzhuang.ji@ly.com","commits":2,"url":"https://github.com/Boswell"},{"name":"Boswell","username":"Boswell","email":"aiyoudqrjmz@163.com","commits":2,"url":"https://github.com/Boswell"},{"name":"mingzhuang.ji","username":"mingzhuang.ji","email":"mingzhuang.ji@ly.com","commits":2,"url":"https://github.com/mingzhuang.ji"}]},"filePathRelative":"books/javascript/数据结构与算法javascript描述/10二叉树和二叉查找树/readme.md"}');export{u as comp,m as data};
