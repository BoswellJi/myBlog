import{_ as l,c as r,e as t,o as i}from"./app-XEG1kVcG.js";const a={};function u(o,e){return i(),r("div",null,e[0]||(e[0]=[t('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p><code>WebGLRenderbuffer</code> : 保存一个图像的缓存并且可以用于渲染操作的源或者目标；</p><ol><li><p>gl.createFramebuffer()：创建帧缓冲区；</p></li><li><p>gl.createTexture(), gl.bindTexture(), gl.texImage2D(), gl.Parameteri()：创建纹理对象并设置其尺寸和参数；</p></li></ol><ul><li></li></ul><ol start="3"><li>gl.createRenderbuffer()/gl.deleteRenderbuffer(renderbuffer)：创建/删除渲染缓冲区对象；</li></ol><ul><li>gl.deleteRenderbuffer(renderbuffer): <ul><li>renderbuffer: 渲染缓冲区对象</li></ul></li></ul><ol start="4"><li>gl.bindRenderbuffer(), gl.renderbufferStorage()： <code>绑定渲染缓冲区对象</code> 并 <code>设置其尺寸</code> ；</li></ol><ul><li><p>使用创建出来的渲染缓冲区之前，需要先将其绑定到目标上，然后通过对目标做一些额外的操作来设置渲染缓冲区的尺寸参数；</p></li><li><p>gl.bindRenderbuffer(target, renderbuffer):</p><ul><li>target: gl.RENDERBUFFER</li><li>renderbuffer: 指定的渲染缓冲区对象</li></ul></li><li><p>gl.renderbufferStorage(target, internalform, width, height): 设置渲染缓冲区的格式，宽度，高度等</p><ul><li><code>作为深度关联对象的渲染缓冲区，其宽度和高度必须与作为颜色关联对象的纹理缓冲区一致</code></li><li>target: gl.RENDBUFFER</li><li>internalform: 指定渲染缓冲区中的数据格式</li></ul></li></ul><ol start="5"><li>gl.bindFramebuffer(), gl.framebufferTexture2D()：将 <code>帧缓冲区的颜色关联对象</code> ，指定为一个 <code>纹理对象</code> ；</li></ol><ul><li><p>先将缓冲区绑定到目标上，然后通过操作目标来操作缓冲区对象；</p></li><li><p>gl.bindFramebuffer(target, framebuffer)：</p><ul><li>target: gl.FRAMEBUFFER</li><li>framebuffer: 指定被绑定的真缓冲区对象； <code>null:已经绑定的帧缓冲区对象，将被解绑</code></li></ul></li><li><p>gl.framebufferTexture2D(target, attachment, textarget, texture, level):</p><ul><li>textarget: 映射类型 gl.TEXTURE_2D</li><li>texture: 指定的纹理对象</li><li>level: 纹理的层级</li></ul></li></ul><ol start="6"><li>gl.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)：将 <code>帧缓冲区的深度关联对象</code> ，指定为一个 <code>渲染缓冲区对象</code> ；</li></ol><ul><li><p>帮助进行隐藏面消除；</p></li><li><p>target: gl. FRAMEBUFFER</p></li><li><p>attachment: 指定关联的类型</p></li><li><p>renderbuffertarget: gl. RENDERBUFFER</p></li><li><p>renderbuffer: 指定的渲染缓冲区对象</p></li></ul><ol start="7"><li>gl.checkFramebufferStatus(target): 检查帧缓冲区是否配置正确；</li></ol><ul><li>0：target不是gl. FRAMEBUFFER；</li></ul><ol start="8"><li>gl.bindFramebuffer(gl. FRAMEBUFFER, target)：把绘制目标从 <code>颜色缓冲区</code> 切换为 <code>帧缓冲区</code> ；</li></ol><ul><li>这样gl.drawArrays()和gl.drawElements()函数就会在帧缓冲区中进行绘制；</li><li>gl.bindFramebuffer(gl. FRAMEBUFFER, null): 把绘制目标切换为颜色缓冲区;</li><li>gl.clear(gl. COLOR_BUFFER_BIT | gl. DEPTH_BUFFER_BIT): 清空颜色缓冲区和深度缓冲区；</li></ul><ol start="9"><li>gl.deleteFramebuffer()：删除帧缓冲区</li></ol>',17)]))}const n=l(a,[["render",u],["__file","3如何实现渲染到纹理.html.vue"]]),f=JSON.parse('{"path":"/books/%E5%9B%BE%E5%BD%A2%E5%AD%A6/webgl/webgl%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/10%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]}],"git":{"updatedTime":1735558340000,"contributors":[{"name":"jmz","username":"jmz","email":"mingzhuang.ji@ly.com","commits":4,"url":"https://github.com/jmz"},{"name":"Boswell","username":"Boswell","email":"mingzhuang.ji@ly.com","commits":2,"url":"https://github.com/Boswell"},{"name":"Boswell","username":"Boswell","email":"aiyoudqrjmz@163.com","commits":2,"url":"https://github.com/Boswell"},{"name":"mingzhuang.ji","username":"mingzhuang.ji","email":"mingzhuang.ji@ly.com","commits":2,"url":"https://github.com/mingzhuang.ji"}]},"filePathRelative":"books/图形学/webgl/webgl编程指南/10高级技术/3如何实现渲染到纹理.md"}');export{n as comp,f as data};
